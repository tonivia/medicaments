# -*- coding:utf-8 -*-
'''
Created on 9 juil. 2014

@author: tvialette
'''
import numpy as np
import pandas as pd
from pandas import DataFrame
import pdb
import datetime as dt
import matplotlib.pyplot as plt
import scipy.stats as stats


from medic_gouv import load_medic_gouv
from medicam import load_medicam

# parametres du calcul
period = range(2002,2014)
info_utiles_from_gouv = ['CIP7','Id_Groupe','Type', 'Date_declar_commerc', 'Taux_rembours','Prix']

# chargement des donnees
medicam, axis0, axis1, axis2 = load_medicam(period)
maj_bdm = 'maj_20140630\\'
gouv = load_medic_gouv(maj_bdm, var_to_keep=info_utiles_from_gouv, CIP_not_null=True)

# On mets les dates au format datetime
for var in info_utiles_from_gouv:
    if 'date' in var or 'Date' in var:
        gouv[var]  = gouv[var].map(lambda t : dt.datetime.strptime(t,"%d/%m/%Y").date())

## ajoute des données dans médicam
base_idx = axis2.index('base')
# Pour chaque médicament on détermine l'année de la première vente :
premiere_vente = pd.Series(index=axis0.index)
derniere_vente = pd.Series(index=axis0.index)
for year in range(len(period)):
    vente = medicam[:,year,base_idx] > 0
    cond_prem = vente & premiere_vente.isnull()
    premiere_vente[cond_prem] = year + min(period)
    cond_dern = ~vente & premiere_vente.notnull() & derniere_vente.isnull()
    derniere_vente[cond_dern] = year - 1 + min(period)
    
axis0['premiere_vente'] = premiere_vente
axis0['derniere_vente'] = derniere_vente

base_brute = pd.merge(gouv, axis0, on='CIP7')


##### On fait maintenant l'exploitation à partir de groupe : 
### Un groupe c'est : un identifiant de groupe + un indicateur du statut dans chaque groupe
### Exemple : Id_groupe et is_princeps
base_brute['group'] = base_brute['Id_Groupe']
base_brute['role'] = base_brute['Type'] == 0

#On concerve sulement les medicaments dont on connait le groupe generique
base_brute = base_brute.loc[base_brute['group'].notnull()]
base_brute['group'] = base_brute['group'].astype(int)
base_brute['role'] = base_brute['role'].astype(bool) #pour faire planter si on a trois groupes...
# quelques infos pour faire joli
nombre_cip = len(base_brute['CIP7'].unique())
taille_base_brute = len(base_brute)
print "La base base_brute provisoire dont tous les medicaments ont un groupe generique defini contient " + str(taille_base_brute) + \
    " lignes pour " + str(nombre_cip) + " medicaments uniques (CIP)."



### Date de chute du brevet, se généralise en "modification du groupe" ? 
## On a deux méthodes concurrentes
grp = base_brute.groupby('group')



chute_brevet1 = grp.apply(lambda group: group.loc[~group['role'],'premiere_vente'].min())

chute_brevet2 = grp.apply(lambda group: group.loc[~group['role'],'Date_declar_commerc'].min())
chute_brevet2_year = pd.Series(index = chute_brevet2.index)
chute_brevet2_month = pd.Series(index = chute_brevet2.index)
chute_brevet2_month[chute_brevet2.notnull()] = chute_brevet2[chute_brevet2.notnull()].apply(lambda x: x.month)
chute_brevet2_year[chute_brevet2.notnull()] = chute_brevet2[chute_brevet2.notnull()].apply(lambda x: x.year)

chute_brevet2_year[chute_brevet2_year < 2002] = 2002


# base_brute['premiere_vente'].fillna(period[-1] + 1)
# grp_generic_only = base_brute[~base_brute['role']].groupby('group')
# chute_brevet1 = grp_generic_only['premiere_vente'].min() + min(period)
# chute_brevet2 = grp_generic_only['Date_declar_commerc'].min()
chute_brevet1[chute_brevet1.isnull()] = 0
chute_brevet2_year[chute_brevet2_year.isnull()] = 0
isdiff = chute_brevet1 != chute_brevet2_year
diff = chute_brevet2_year[isdiff] - chute_brevet1[isdiff]
# diff.value_counts()
# exemple = diff[diff == -1].index
# exemple = base_brute[id_group.isin(exemple)]
#  print "Il y a " + str(len(diff)) + " groupes dont les deux méthodes d'estimation de l'année de chute du brevet montrent une différence."


# grp['role'].sum()
# grp['is_generic'].sum().value_counts()
# (grp.size() - grp['is_generic'].sum()).value_counts()

#Fonciton permettant de lire les valeurs dans medicam
def _index_group_medicam(group_id):
    ''' retourne l'indice des médicaments de group_id '''
    list_cip = grp['CIP7'].get_group(group_id)
    select = axis0['CIP7'].isin(list_cip)
    return axis0.index[select].tolist()
 
def _sum_for_group(group, medicam, period):
    ''' retourne la somme du groupe générique par année'''
    group_id = group['group'].values[0]
    index0 = _index_group_medicam(group_id)
    data = DataFrame(columns=period, index=None)
    data.loc[0,:] = medicam[index0,:].sum(axis=0)
    return data
 
def sum_by_group(groupby, period, variable):
    ''' retourne une table avec pour chaque group de groupby
      la somme de la variable sur toutes les années de period
    '''
    min_axis1 = min(axis1)
    index1 = [year - min_axis1 for year in period]
    index2 = axis2.index(variable)
    medicam_selected = medicam[:,:,index2]
    medicam_selected = medicam_selected[:,index1]
    output = groupby.apply(_sum_for_group, medicam_selected, period)
    output.set_index(output.index.levels[0], inplace=True)
    return output
    

grp_princeps = base_brute[base_brute['role']].groupby('group')
nombre_princeps = sum_by_group(grp_princeps, period, variable='nombre')

grp_generic = base_brute[~base_brute['role']].groupby('group')
nombre_generic = sum_by_group(grp_generic, period, variable='nombre')


# Définitiont du groupe d'intéret
#on veut des génériques et des princips
chute_brevet = (grp['role'].sum() > 0) & (grp.size() - grp['role'].sum() > 0)
# on veut garder que les mois autours du 1 janvier
month_tolerance = 1
debut_annee = (chute_brevet2_month <= month_tolerance) | (chute_brevet2_month > 12 - month_tolerance)
chute_brevet2_year[chute_brevet2_month > 6] += 1 #on considère que si on est en fin d'année, les génériques 
# sont mis sur le marché l'année d'après
cond = debut_annee & chute_brevet & ~isdiff
cond = cond & (chute_brevet2_year > 2002) & (chute_brevet2_year < 2013)

def select(table):
    ''' Permet d'appliquer les conditions à la table '''
    table = table.loc[cond.index[cond]]
    return table

def evolution_bis(table):
    evolution = pd.DataFrame(index = table.index, columns = period)
    for year in period[1:]:
        cond = table[year-1] != 0
        evolution.loc[cond, year] = (table.loc[cond, year] - table.loc[cond, year-1])/table.loc[cond, year-1]
        evolution.loc[~cond, year] = 0
    return evolution 

def evolution_ter(table):
    evolution = pd.DataFrame(index = table.index, columns = period[1:])
    table[table==0] = None
    for year in period[1:]:
        evolution[year] = (table[year] - table[year-1])/table[year-1]
    return evolution

evolution_princeps = evolution_ter(select(nombre_princeps))

pdb.set_trace()



#Mesure des trends:
#tendance = pd.DataFrame(index = evolution_princeps.index, columns=('avant', 'après'))
#for grp in tendance.index:
#    interet = evolution_princeps[evolution_princeps.index == grp]
#    tendance.avant[grp] = np.mean([interet[year] for year in range[pre+1:chu]])



group_with_generic = grp.apply(lambda x: x['role'].sum() > 0)

evolution_princeps[evolution_princeps.isnull()] = 0
test = sum([evolution_princeps[year] for year in evolution_princeps[1:]])


import timeit
t = timeit.Timer("evolution(nombre_generic)", setup="from __main__ import evolution, nombre_generic")
t_bis = timeit.Timer("evolution_bis(nombre_generic)", setup="from __main__ import evolution_bis, nombre_generic")

print ' ta méthode prend ' + str(t.timeit(number=1)) + ' secondes'
print ' la mienne prend ' + str(t_bis.timeit(number=100)/100) + ' secondes'
print (" --> Stop looping !")
# TODO: remove evolution and var



    
def evolution(table):
    table[table==0] = None
    for year in table.columns[1:]:
        list_var = (table[year]-table[year-1])/table[year-1]
        table[year] = list_var
    return table[table.columns[1:]]
